{
  "key": "dodao-course-template",
  "title": "Introduction to Arbitrum",
  "summary": "This is a course that provides a deeper understanding towards the working and technicalities of Arbitrum, a cutting-edge layer-2 scaling solution designed to enhance the capabilities of Ethereum, one of the most prominent blockchain platforms. In this course, we will delve into the intricacies of Arbitrum, exploring its two major chains: Arbitrum One and Arbitrum Nova. Our journey will guide you through the fundamentals of layer-2 solutions, the specific features and advancements of Arbitrum, and how it integrates with the Ethereum network to provide faster, more efficient transactions.\n\nThis course offers a blend of theoretical knowledge and practical insights. You will learn about the technical underpinnings of Arbitrum, including its unique approach to transaction processing and dispute resolution. The course also covers the differences between Arbitrum Classic and Nitro, highlighting the advancements in efficiency, gas fees, and Ethereum compatibility.\n\nWhether you are a developer looking to build on Arbitrum, an investor interested in understanding its impact on the Ethereum ecosystem, or simply a blockchain aficionado eager to expand your knowledge, this course provides valuable insights. By the end, you will have a thorough understanding of Arbitrum's role in the evolving landscape of blockchain technology and its potential to shape the future of decentralized applications. ",
  "details": "",
  "duration": "30 mins - 1 hour",
  "highlights": [
    "Introduction",
    "Arbitrum Nitro",
    "Arbitrum One",
    "Arbitrum Nova",
    "Arbitrum Orbit",
    "Arbitrum Stylus"
  ],
  "publishStatus": "Live",
  "thumbnail": "https://d31h13bdjwgzxs.cloudfront.net/courses/DoDAO/CourseIcons/audit_and_monitoring.png",
  "courseAdmins": [
    "0x34d014758297c00fea49935fce172677904d51ef",
    "0x2a6af0619be90d129ab0d70c10e25c097b6ec67d"
  ],
  "topicConfig": {
    "showExplanations": true,
    "showHints": true
  },
  "topics": [
    {
      "title": "Introduction",
      "key": "introduction",
      "details": "## What is Arbitrum\n\nArbitrum is a Layer 2 scaling solution designed to enhance the Ethereum blockchain's scalability and efficiency. It processes transactions separately from Ethereum's main chain and utilizes Rollup technology to combine multiple transactions into one, increasing throughput and reducing costs. Arbitrum maintains compatibility with Ethereum's existing tools and smart contracts, allowing for straightforward application deployment. Developed by Offchain Labs, it includes the Arbitrum One mainnet, which supports smart contract execution with Ethereum network validation. The use of Arbitrum significantly lowers transaction fees, making it a cost-effective alternative for running decentralized applications and smart contracts compared to Ethereum's mainnet.\n\n## What is Layer 2 \n\nLayer 2 refers to a secondary framework or protocol that is built on top of an existing blockchain system, known as Layer 1. The primary purpose of Layer 2 solutions is to address the scalability and performance issues of the main blockchain by handling transactions off the main chain. This allows for faster processing times and reduced transaction costs, without compromising the decentralized security model of the underlying blockchain. Layer 2 solutions include various technologies such as state channels, sidechains, and rollups, each with their own approach to off-chain transaction handling and subsequently settling the final state on-chain.\n\n<div align=\"center\">\n  <img style=\"max-height:600px;margin-bottom:40px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/introduction_to_arbitrum_arbitrum_university_794/1700676990117_lyer_2.png\"/>\n</div>\n\n## Benefits of Layer 2\n\n1. **Increased Transaction:** Throughput By handling transactions off the main chain, Layer 2 can process many more transactions per second than the base layer, alleviating congestion.\n\n2. **Reduced Costs:** Transactions on Layer 2 typically incur lower fees because they minimize the demand on the network's main chain resources.\n\n3. **Improved Speed:** Transactions can be completed faster on Layer 2, as they are not subject to the longer processing times of the main chain.\n\n<div align=\"center\">\n  <img style=\"max-height:600px;margin-bottom:40px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/introduction_to_arbitrum_arbitrum_university_794/1700677028811_benefits.png\"/>\n</div>\n\n4. **Enhanced Scalability:** Layer 2 can scale independently from the main chain, allowing the network to support more users and applications without a proportional increase in transaction costs or times.\n\n5. **Maintained Security:** Despite processing transactions off-chain, Layer 2 solutions typically inherit the strong security guarantees of the underlying main chain.\n\n",
      "order": 0,
      "explanations": [
        {
          "key": "arbiturm-optimistic-rollup",
          "shortTitle": "Optimistic Rollup",
          "details": "## Roll Ups\nRollups are a type of Layer 2 scaling solution that execute transactions outside the main Ethereum chain (off-chain) but record transaction data on the main chain (on-chain). The core idea is to \"roll up\" or batch many transactions into a single one, which is then posted to the main chain. This reduces the amount of data that needs to be stored and processed on the main chain, significantly increasing throughput and reducing transaction fees.\n\n### Types of Roll ups\nThere are two main types of rollups, each with its own approach to validating the batched transactions:\n\n#### Optimistic Rollups\nThese operate on the principle that all transactions are assumed to be valid by default. They only execute transaction computations on-chain in the event of a challenge. This means that instead of performing computation to prove the correctness of transactions upfront, Optimistic Rollups post the transactions along with a bond. After a challenge period, if no one disputes the transaction batch with a \"fraud proof\" showing that something was wrong, the transactions are considered valid. This method allows for significant scaling benefits, but the challenge period can introduce a delay in finalizing transactions.\n\n<div align=\"center\">\n  <img style=\"max-height:600px;margin-bottom:40px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/introduction_to_arbitrum_arbitrum_university_794/1700677076473_types_of%20rollups.png\"/>\n</div>\n\n#### Zero-Knowledge Rollups (ZK-Rollups)\nZK-Rollups bundle transactions and generate a cryptographic proof, known as a zero-knowledge proof (specifically, a zk-SNARK or zk-STARK), attesting to their validity. This proof is then posted to the main chain, where it can be quickly verified. Because the validity of the entire batch can be confirmed without executing the transactions individually, ZK-Rollups can finalize transactions much more quickly than Optimistic Rollups. Additionally, ZK-Rollups enhance privacy since the actual transaction data can be kept off-chain.\n\n## Optimistic Rollup; How it works?\nOptimistic Rollups operates on the assumption that all transactions are honest and valid unless proven otherwise. Here's how they work:\n\n#### Step 1: Execution and Aggregation\nIn optimistic rollups, operators, or validators, process transactions by aggregating and compressing them before submitting them to Ethereum's blockchain. Any user can act as a validator by providing a bond, similar to proof-of-stake systems, and risks penalties for any invalid submissions. Validators also maintain their version of the rollup's state and can issue fraud proofs if discrepancies arise. Some rollups use a 'sequencer' instead of multiple validators, which centralizes transaction processing and submission but provides greater control over transaction order and immediate access to the rollup chain.\n\n#### Step 2: Sending Roll up Blocks to Ethereum\nOperators consolidate multiple off-chain transactions into a single batch and compress the transaction data to minimize storage costs on Ethereum. This batch is then submitted to Ethereum as 'calldata' — a temporary and immutable form of data used by smart contracts to execute functions. While 'calldata' remains in the blockchain's history, it does not become part of the Ethereum state, thereby conserving space and reducing costs. The 'calldata' keyword in Solidity is instrumental in calling smart contract functions and organizing inputs, playing a critical role in the efficient operation of optimistic rollups. \n\n#### Step 3: State Commitments\nState commitments play a crucial role in maintaining the integrity of the system. The state is structured as a Merkle tree, also known as the state tree, which contains all the information about the current state of the rollup. Operators compute new state roots reflecting the latest state changes and submit these roots to the rollup contract on Ethereum. By committing to the old and new state roots when posting transaction batches, and including the Merkle root for transactions, operators provide a verifiable record of the rollup's state changes on the Layer 1 blockchain. This mechanism ensures that the state of the rollup can be trusted and verified.\n\n<div align=\"center\">\n  <img style=\"max-height:600px;margin-bottom:40px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/introduction_to_arbitrum_arbitrum_university_794/1700677113051_working_of%20rollup.png\"/>\n</div>\n\n#### Step 4: Fraud Proof \nThe essence of optimistic rollups lies in their fraud-proof mechanism. They allow blocks to be published without immediate validity checks. If discrepancies are suspected, users can challenge transitions within a set timeframe. Challenges trigger fraud-proof calculations, where disputed transactions are replayed on Ethereum's main network through a verifier contract. If fraud is confirmed, the responsible validator is penalized. To support this, rollups must make detailed state commitments and transaction data public on-chain, which incurs gas fees. Multi-round interactive proofs can enhance this process's efficiency by reducing the data and computation required for each verification step.\n\n#### Step 5: Multiround Interactive Proving\nMulti-round interactive proving is a critical component of optimistic rollups. It involves a dialogue between a challenger and the block's producer (asserter/operator), overseen by a Layer 1 verifier contract. If a block is challenged, the operator splits the disputed assertion for the rollup block into two, with each part undergoing repeated division through a bisection protocol until the specific point of contention is isolated. The verifier contract then adjudicates the dispute and identifies any fraudulent activity. This process ensures that only valid transactions are finalized, with the capability to penalize malicious actors, thereby maintaining the integrity of the rollup.  ",
          "title": "Arbiturm - Optimistic Rollup"
        },
        {
          "key": "arbitrum-chains",
          "shortTitle": "Types of Chains",
          "details": "Arbitrum ecosystem consists of various chains with distinct features that utilise unique technologies that enable ethereum scalability. The major arbitrum chains include.\n\n### Arbitrum One\nArbitrum One is a Layer 2 optimistic rollup solution that enhances Ethereum blockchain. It doesn't require any additional trust beyond that which is inherent to Ethereum's Layer 1. Enabled by the Nitro technology stack, Arbitrum One features efficient data handling and execution, improved transaction compression, and compatibility with Ethereum's gas system, streamlining the process while keeping security tight.\n\n### Arbitrum Nova\nArbitrum Nova is a Layer 2 scaling solution designed for high performance and cost efficiency. It operates on the AnyTrust protocol, which is a slightly less trustless system compared to Arbitrum One's Rollup protocol. The primary distinction lies in the AnyTrust protocol's reliance on a Data Availability Committee (DAC) to manage transaction data. This committee ensures the speedy and efficient handling of Level 2 transaction data before it is finalized on Ethereum's main chain. Arbitrum Nova is tailored for applications where high throughput and affordability are prioritized.\n\n<div align=\"center\">\n  <img style=\"max-height:600px;margin-bottom:40px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/introduction_to_arbitrum_arbitrum_university_794/1700677166386_chains.png\"/>\n</div>\n\n### Arbitrum Orbit\nArbitrum Orbit allows the creation of personalized chains that settle transactions to Arbitrum's Layer 2 chains, such as Arbitrum One or Arbitrum Nova. You have full control over your Orbit chain, with the ability to tailor its privacy settings, permissions, governance structure, and fee token according to your specific requirements. Orbit chains can be as open or restricted as you prefer, offering a customizable path to decentralization and the option to integrate ongoing enhancements from the Arbitrum Nitro technology stack\n\n## How is arbiturm diferent from other Optimistic L2 Rollups?\nArbitrum's approach prioritizes a balance of speed, cost, security, and developer accessibility, underpinning its leading market position. Some of the major differences include:\n\n### Fraud Proofs\nArbitrum sets itself apart from other Optimistic L2 Rollups primarily through its multi-round fraud proof system, which contrasts with single-round fraud proofs used by platforms like Optimism. This system verifies only challenged transactions, which may result in lower fees due to decreased reliance on Layer 1 computations.\n\n<div align=\"center\">\n  <img style=\"max-height:600px;margin-bottom:40px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/introduction_to_arbitrum_arbitrum_university_794/1700677202817_difference.png\"/>\n</div>\n\n### Virtual Machine Compatibility\nThe Arbitrum Virtual Machine (AVM) is more closely optimized for EVM coding languages, making it developer-friendly as applications don't need to be rewritten to transition from the EVM to the AVM. This contrasts with Optimism's Virtual Machine (OVM), which has faced some compatibility issues with the EVM.\n\n### Transaction Finality and Fees\nDue to the multi-round fraud proof mechanism, transaction finality on Arbitrum can be slower compared to some other rollups, but this trade-off allows for lower fees because of reduced Layer 1 computation reliance​.",
          "title": "Arbitrum Chains"
        },
        {
          "key": "arbitrum-ecosystem",
          "shortTitle": "Arbitrum Community",
          "details": "The Arbitrum ecosystem boasts a vibrant network of decentralized applications, offering users enhanced transaction speed and reduced costs. With its robust compatibility with Ethereum's tools and smart contracts, it simplifies the developer experience for deploying dApps. \n\n## Stylus\nStylus is an innovative platform that extends smart contract development on the Ethereum blockchain to languages like Rust, C, and C++, diversifying beyond the conventional Solidity-centric approach. Integrated with Arbitrum Nitro's enhanced tech stack, Stylus employs the WebAssembly (WASM) virtual machine in tandem with the Ethereum Virtual Machine (EVM), enabling the execution of smart contracts authored in WASM-compatible languages on the Arbitrum network.\n\nStylus enhances the Arbitrum ecosystem by allowing developers to write smart contracts in Rust, C, and C++ and introducing significant performance enhancements for decentralized applications. It also adds the ability to create custom precompiles for advanced cryptographic functions, which, along with WASM support, enables high-speed execution and broader innovation, all while maintaining compatibility with the Ethereum ecosystem through its EVM+ integration.\n\n## Ecosystem Support\nArbitrum offers a robust support ecosystem for its users, emphasizing accessibility and community engagement. The cornerstone of this support is detailed documentation and academy site that provides a wealth of information on platform functionalities and integration processes. For interactive assistance and community-driven support, Arbitrum hosts channels like Discord, where users can seek advice, troubleshoot in real-time, and engage with both peers and the Arbitrum team. Additionally, a bug bounty program encourages the community to contribute to the platform's security, rewarding those who identify and report vulnerabilities. Users are also empowered through the Arbitrum DAO to participate in governance, offering a platform to propose and vote on changes, ensuring that the community's voice is integral to the network's evolution. For direct inquiries, a dedicated support team is likely available to handle specific issues, providing personalized help.\n\nArbitrum's comprehensive support fosters community, loyalty, and platform security, as users contribute to identifying issues via the bug bounty program. Educational resources and tutorials empower users, while governance participation ensures a democratic, community-aligned platform. This support system is vital for user operations and the network's ongoing enhancement and resilience.\n\n<div align=\"center\">\n  <img style=\"max-height:600px;margin-bottom:40px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/introduction_to_arbitrum_arbitrum_university_794/1700677255572_ecosystem.png\"/>\n</div>\n\n\n## Decentralize governance\nArbitrum's decentralized governance is orchestrated through the Arbitrum DAO, which allows stakeholders to vote on key decisions affecting both the Arbitrum One and Arbitrum Nova chains. The governance structure includes a Security Council that can make urgent or minor changes, as well as a set of allow-listed validators who confirm the chains' states. For Arbitrum Nova, there's also a Data Availability Committee tasked with data storage and availability. The governance system has the power to modify validators and Sequencers, who are responsible for transaction ordering, thereby maintaining a balance between central oversight and progressive decentralization. This governance framework is designed to evolve, with the potential for changes based on community feedback, reflecting the adaptive nature of the protocol's management.\n\nProgressive decentralization is a strategic approach to building trust and stability within a blockchain ecosystem. It starts with a centralized authority, such as the core development team, who can quickly respond to issues and update the system efficiently. Over time, control is handed over to a broader set of stakeholders, which enhances security by reducing central points of failure. It also deepens community involvement, as more participants are empowered to govern the network, which in turn fosters a more resilient and democratic infrastructure. This gradual transition allows the network to maintain continuity and stability while progressively mitigating risks and adapting to a decentralized governance structure.",
          "title": "Arbitrum Ecosystem"
        }
      ],
      "questions": [],
      "readings": [],
      "summaries": []
    },
    {
      "key": "arbitrum-nitro",
      "title": "Arbitrum Nitro",
      "details": "## What is Arbitrum Nitro?\n\nArbitrum Nitro is a significant technical upgrade for Arbitrum, which is a Layer 2 scaling solution for Ethereum. It aims to lower transaction fees and increase the processing capacity of Ethereum by moving contract computation and storage from the primary chain. This upgrade, known as Nitro, is designed to be more compatible with the Ethereum Virtual Machine (EVM) and provides a better user experience with lower fees and faster transactions. With Nitro, Arbitrum aims to push the boundaries of security, efficiency, and scalability, offering a promising solution for the future of Ethereum. \n\n<div align=\"center\">\n  <img style=\"max-height:600px;margin-bottom:40px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/arbitrum_nitro_arbitrum_university_560/1700677384029_nitro.png\"/>\n</div>\n\nIt introduces advanced calldata compression, reducing transaction costs even further. Nitro enhances the performance of Layer 1 (L1) nodes, aligns EVM operation pricing with Ethereum, and introduces additional synchronization with Ethereum L1 blocks. As it seamlessly supports the Ethereum Virtual Machine (EVM), no hefty modifications are required. With Nitro, transactions on Arbitrum have become extremely efficient. \n\n## Innovative Features of Arbitrum Nitro\n\n#### WebAssembly Code\n\nNitro introduces a new prover that uses WebAssembly (WASM) code to perform Arbitrum's interactive fraud proofs. This upgrade enhances the scalability and efficiency of the system, allowing for thousands of transactions to be processed per second. Despite being a separate blockchain, Arbitrum Nitro maintains the security and privacy features of Ethereum's Layer 1 (L1) and relays all transaction information to the main Ethereum chain.\n\n<div align=\"center\">\n  <img style=\"max-height:600px;margin-bottom:40px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/arbitrum_nitro_arbitrum_university_560/1700677415896_features.png\"/>\n</div>\n\n#### EVM Compatiblility\n\nDevelopers can easily integrate Arbitrum Nitro without making any modifications because it supports the EVM. This means that existing Ethereum contracts and transactions can run on Arbitrum without any changes. This distinguishes Arbitrum Nitro from other layer 2 solutions as each have their own VMs thereby requiring modifications for integration. \n\n#### Deterministic Transactions\n\nTo use Arbitrum Nitro, users need to submit their transactions to the chain's inbox. The chain will then execute the transaction and produce outputs, including a transaction receipt and any initiated withdrawals. The execution of transactions is deterministic, meaning that the result is known as soon as the transaction is placed in the inbox. Arbitrum ensures the correctness of the chain state and outputs, supports Ethereum-compatible contracts and transactions, and manages the transfer and management of ETH and tokens on the chain. ",
      "explanations": [
        {
          "key": "nitro-vs-classic",
          "shortTitle": "Differences",
          "details": "\nHere is the comparison between Arbitrum Nitro and Arbitrum Classic (original version of Arbitrum):\n\n| Feature                                  | Arbitrum Classic                                              | Arbitrum Nitro                                                  |\n|------------------------------------------|---------------------------------------------------------------|-----------------------------------------------------------------|\n| Goal                                     | Execution environment resembling EVM as second layer to Ethereum | Execution environment resembling EVM as second layer to Ethereum |\n| Virtual Machine Used                     | Arbitrum Virtual Machine (AVM)                                  | WebAssembly (Wasm)                                              |\n| Low-Level Instructions                   | Uses AVM for low-level instructions                             | Compiles Go code to WASM for low-level instructions             |\n| Architecture                             | Relies on AVM for execution environment                         | Direct usage of Geth's EVM implementation, enhancing efficiency |\n| Gas Fees and Ethereum Compatibility      | Higher fees compared to Nitro, due to less optimized execution environment | Lower fees and better Ethereum compatibility due to native execution of Go code |\n| Codebase Simplicity                      | More complex due to custom AVM, posing higher technical risks   | Simpler and more accessible codebase, reducing technical risks  |\n| Coding Languages                         | Solidity or Vyper                                                | Go (a more common language)                                     |\n| Code Conversion                          | EVM bytecode converted to AVM bytecode                           | Uses Wasm only when there's a dispute                           |\n| Transaction Management and Fraud Proofs  | AVM bytecode runs transactions and generates fraud proofs        | Checkpoints summarize transactions; Wasm used for disputes      |\n| Dispute Resolution                       | Validators inspect AVM bytecode in case of disputes              | Validators agree on block before examining Wasm details         |\n| Efficiency and Resource Management       | Less efficient, prepares for problems even if they do not occur  | More efficient, converts to Wasm only during disputes, saving time and resources |",
          "title": "Nitro vs Classic"
        },
        {
          "key": "arbitrum-nitro-design",
          "shortTitle": "Architecture",
          "details": "## How Transactions Work?\n\nDesigned to enhance efficiency and streamline workflows, the Nitro design emerges as an evidence to innovation in the Ethereum ecosystem. The transaction pocess in Arbitrum Nitro technology consists of the following cricial steps:\n\n#### Step 1: Sequencing and Deterministic Execution\n\nWhen a user sends a transaction on the Nitro chain, it is signed with their wallet and given to the Sequencer. The Sequencer orders transactions and publishes them, after which they're processed to update the Nitro chain state, producing Layer 2 blocks as needed. Invalid transactions are rejected to keep the sequence authentic. The Sequencer uses a real-time alert system for immediate soft finality and batches transactions on the Ethereum chain for hard finality. The latter involves compressing transactions using \"brotli\" and posting them to Ethereum, where their finalization ensures the sequence's immutability on Nitro.\n\n<div align=\"center\">\n  <img style=\"max-height:600px;margin-bottom:40px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/arbitrum_nitro_arbitrum_university_560/1700677469815_transaction_lifecycle.png\"/>\n</div>\n\n#### Step 2: State Transition Function\n\nIn Arbitrum Nitro's transaction lifecycle, the State Transition Function (STF) is crucial for updating the blockchain's state. Once a transaction is submitted, it enters the Nitro system either through a Sequencer or directly into the inbox. The STF then processes these transactions, taking the current state and the transaction data to compute a new state. It performs all the necessary calculations and state alterations in a deterministic manner, such as adjusting account balances and modifying smart contract states. This transition is then reflected on the chain, with the STF ensuring that the state progresses correctly and consistently after each transaction, maintaining the integrity and continuity of the blockchain's ledger.\n\n#### Step 3: Posting on Layer 1\n\nIn Arbitrum Nitro's transaction lifecycle, data posting on Layer 1 is where transaction inputs are recorded as calldata on the Ethereum blockchain, allowing for full transparency and enabling anyone to reconstruct the chain's state. This process supports the network's optimistic rollup approach, where validators post proposed rollup blocks to Layer 1, which are assumed correct unless challenged within a roughly one-week period. If unchallenged, the block is confirmed, but disputed blocks trigger Arbitrum's dispute resolution protocol to determine accuracy, penalizing dishonest validators with deposit forfeiture. This design ensures the integrity of posted data while minimizing fraud.\n\n## Nitro Under the Hood\n\nArbitrum Nitro's innovative architecture is designed to streamline both the execution of smart contracts and the verification process in case of disputes. Central to this architecture is the implementation of \"geth at the core,\" which utilizes go-ethereum, the commonly used Ethereum node software, written in the Go programming language. This foundational approach is manifested in a layered structure. Nitro harnesses the power of this setup to optimise performance while maintaining the robustness of security and verification processes.\n\n### Layers of Nitro Node\n\nNitro utilizes the same source code for two distinct tasks: execution and proving, by employing \"geth at the core.\" The Nitro node software, predominantly written in Go like go-ethereum (geth), consists of three main layers—the base layer with core geth functionalities, the middle layer called ArbOS providing Layer 2 features, and the top layer handling node operations, also derived from geth. This layered design forms the \"geth sandwich,\" with geth as the bread and ArbOS as the filling.\n\n<div align=\"center\">\n  <img style=\"max-height:600px;margin-bottom:40px\" src=\"https://d31h13bdjwgzxs.cloudfront.net/academy/arbitrum-university/Guide/arbitrum_nitro_arbitrum_university_560/1700677506703_layers.png\"/>\n</div>\n\n### Dual Compilation Strategy\n\nFor execution, the source code is compiled into native code using the standard Go compiler, customized for the specific architecture of the node deployment. In contrast, for proving—particularly important when disputes arise—the same source code, especially the State Transition Function (STF), is compiled to WebAssembly (WASM), a portable machine code format. This WASM code is then transformed into WAVM, a modified version for proof procedures. When a dispute occurs, the verification of the STF's results is conducted with reference to the WAVM code, ensuring that the same logic governs both normal operation and the verification process during disputes.",
          "title": "Arbitrum Nitro Design "
        }
      ],
      "readings": [],
      "summaries": [],
      "questions": []
    },
    {
      "key": "arbitrum-one",
      "title": "Arbitrum One",
      "details": "## What is Arbitrum One ?\nArbitrum One is a Layer 2 optimistic rollup solution developed by Offchain Labs, designed to enhance Ethereum's performance and user experience by handling transactions off the Ethereum Mainnet (Layer 1). It operates on the Arbitrum Rollup protocol and settles to Ethereum's Layer 1, offering high-performance dApps with lower transaction costs and Ethereum-level security without additional trust assumptions. Powered by the Nitro technology stack, Arbitrum One boasts advanced features like calldata compression, separate contexts for execution and fault proving, and Ethereum L1 gas compatibility. Its multi-round interactive Optimistic Rollup approach optimistically assumes the correctness of data posted to the Ethereum mainnet, allowing challenges and efficient dispute resolution at low costs, while maintaining trustless protocol operation, EVM compatibility, and secure fund control for users.\n\n## What is Arbitrum roll up protocol?\nThe Arbitrum Rollup Protocol is a Layer 2 scaling solution that works in tandem with Ethereum's Layer 1, where it doesn't decide the outcomes of transactions but instead confirms the results that are already determined by the sequence of messages in the chain's inbox. Once a transaction is included in the chain’s inbox, its outcome is considered finalized and can be reported as complete. Arbitrum nodes validate these transactions, providing users the confidence that their transactions are processed without the need for constant awareness of the rollup protocol's operation.\n\n### Benefits of Roll up Protocol\nThe purpose of the Arbitrum Rollup Protocol is twofold.\n \n#### Confirms Accuracy\nFirstly, it serves as a trustless method to verify transaction results and to identify and penalize dishonest parties. This is crucial because although the outcomes of transactions are known, without the protocol, there would be no way to confirm their accuracy and resolve disputes definitively. \n\n#### Ethereum Scalability\nSecondly, it relieves Ethereum from the burden of processing every transaction, thereby allowing for scalable operations that Ethereum alone could not efficiently monitor. By only stepping in when a transaction is contested, Ethereum can ensure the integrity of the Arbitrum chain while enabling fast and cost-effective Layer 2 transactions. This not only enhances the scalability of Ethereum but also maintains its security by enabling the confirmation of transactions and the processing of withdrawals back to Layer 1.",
      "explanations": [
        {
          "key": "working-of-roll-ups",
          "shortTitle": "Rollups",
          "details": "## How does Arbitrum Rollup Work?\n\n### RBlocks\nAn RBlock within the Arbitrum Rollup protocol is a specialized type of block that encapsulates the state and progress of the Layer 2 (L2) Arbitrum network. Unlike traditional Ethereum Layer 1 blocks or the typical blocks you might find in other Layer 2 solutions, RBlocks serve a unique purpose in the Arbitrum ecosystem. They are part of a separate chain that the Arbitrum rollup protocol manages, effectively acting as checkpoints or snapshots of the L2 state at various points in time.\n\nAn RBlock in the Arbitrum Rollup chain carries its identifier, the number of the last correct RBlock, the total of L2 blocks made, inbox messages used, and a hash of the chain's outputs. These except the RBlock's number are the proposer's unverified claims, which the protocol must confirm or reject. An RBlock also implies the correctness of all preceding RBlocks back to the origin and contests the validity of any direct older RBlocks. Validators can challenge an RBlock before a deadline by proposing an alternative, which could lead to a staked conflict resolution. Here is a step-by-step guide on how the rollup chain works to confirm the rBlocks\n\n### Step 1: RBlocks Creation\nValidators propose RBlocks, which form a chain managed by the Arbitrum rollup protocol, distinct from Ethereum's Layer 1 and Nitro's Layer 2 blocks. When first proposed, RBlocks are 'unresolved' meaning their status as either confirmed or rejected has not yet been determined. Over time, each RBlock is resolved. Confirmed RBlocks become part of the chain's permanent history.\n\n### Step 2: Chain History and Progress\nConfirmed RBlocks are fully accepted and recorded by Ethereum's Layer 1 contracts. The most recent confirmed RBlock is known as the \"latest confirmed RBlock\". Newer RBlocks are proposed and remain unconfirmed until their resolution deadlines pass. The earliest of these is the \"first unresolved RBlock\".\n\n### Step 3: Building on Proposed RBlocks\nValidators can propose new RBlocks based on the latest proposed (but not yet confirmed) RBlock, enabling the chain to grow continuously without waiting for each RBlock's confirmation. Typically, proposed RBlocks are valid and thus are eventually confirmed.\n\n### Step 4: Dealing with Malicious Validators\nIn cases where validators act maliciously by proposing incorrect RBlocks, the protocol can handle a variety of conflict scenarios such as a confirmed RBlock is fully accepted, a rejected RBlock is discarded for being incorrect. Subsequent RBlocks can be rejected due to incorrect claims or because they build on other rejected RBlocks. Unresolved RBlocks are awaiting confirmation or rejection. If they are built on a rejected RBlock, they will also be rejected.\n\n### Step 5: Resolving Conflicts\nConflicts between RBlocks which claim the same predecessor, will be resolved by the protocol, with at least one being rejected. The protocol resolves RBlocks in numerical order. If an RBlock is rejected, any subsequent RBlocks depending on it are automatically rejected.\n\n### Step 6: Security Assurance\nDespite potential conflicts, the security property of the rollup protocol ensures that even if multiple parties act dishonestly, the correct chain execution will be confirmed, safeguarding the integrity of the rollup chain. Validators may stake ETH as a bond for proposing RBlocks. If they propose a wrong RBlock, they will lose their stake, incentivizing honest behavior.",
          "title": "Working of Roll ups"
        },
        {
          "key": "roll-up-security",
          "shortTitle": "Fraud Proof",
          "details": "## The Roll up security\nArbitrum Rollup's security model leverages the robustness of Ethereum's Layer 1 to offer a Layer 2 scaling solution that doesn't compromise on trustlessness or decentralization. By utilizing a unique combination of on-chain data availability and off-chain computation, it ensures that even if all but one validator acts maliciously, the integrity of transactions is preserved. Moreover, the interactive dispute resolution process allows any honest participant to challenge incorrect claims by staking, thereby maintaining the overall security and reliability of the network. \n\n### Validators\nValidators are essential participants in the Arbitrum Rollup protocol, responsible for proposing and ensuring the accuracy of RBlocks in the network. Some validators, known as stakers, back their commitments with an ETH deposit, which they lose if found cheating. In most cases, only one staker is active to validate the current state unless disputes arise. While the role is intended to be open to all, Arbitrum One currently uses an allowlist for validators. Any honest validator is empowered to enforce the correct processing of transactions, maintaining the chain's trustlessness and security.\n\n## Staking\nStaking the process of holding funds in a cryptocurrency wallet to support the operations of a network. Participants lock or hold their tokens in a wallet to perform various network functions such as validating transactions, maintaining security, and governance. Here's a step-by-step process of staking within the Arbitrum network:\n\n### Step 1: Stake Deposit\nValidators who choose to become stakers deposit ETH into Arbitrum Layer 1 contracts. These deposits are held as collateral and are at risk if the staker is involved in a losing challenge. A single stake can cover a chain of RBlocks. Stakers are automatically staked on the latest confirmed RBlock and may also opt to stake on a successor to that RBlock, committing to a sequence that represents a single, coherent claim about the chain's history. \n\n### Step 2: Staking Conditions\nValidators not currently staked can place a stake on the latest confirmed RBlock by depositing the minimum stake amount. Validators already staked on an RBlock can extend their stake to one successor of that RBlock without additional deposits. Creating a new RBlock as a successor to an RBlock you're staked on is considered an extension of your stake.  If a validator is staked only on the latest confirmed RBlock, they (or anyone else) can request a refund of their stake.\n\n### Step 3: Creating New RBlocks\nTo propose a new RBlock, a validator must be a staker and have an active stake on the RBlock's predecessor. This requirement ensures validators have a vested interest in the accuracy of their proposed RBlocks. The protocol tracks the required stake amount, which typically matches the base stake amount set by the Nitro chain. If the chain is progressing slowly in confirming RBlocks, the required stake amount may temporarily increase.\n\n### Step 4: Commitment and Resolution\nOnce staked on an RBlock, a validator cannot unstake. The stake is either returned following the confirmation of all RBlocks they're staked on, or lost if the staked RBlock is rejected. Losing a challenge results in the removal of the stake from all RBlocks and forfeiture of the staked funds. The minimum stake amount can increase exponentially based on the time elapsed since the deadline of the first unresolved RBlock, to discourage stalling tactics. As the chain resumes normal progress, the stake requirement decreases.\n\nThis staking mechanism is designed to align the validators' financial incentives with the integrity and efficient progression of the Arbitrum chain.",
          "title": "Roll up Security"
        },
        {
          "key": "dispute-resolution",
          "shortTitle": "Resolve dispute",
          "details": "## Dispute Resolution\nThe dispute resolution process in Arbitrum, which utilizes interactive proving, unfolds as follows:\n\n### Step 1: Initiation of Dispute\nThe claiment makes a claim about the result of the chain's computation. The other person challenges their claim, disagreeing with the result they propose. Both parties engage in a back-and-forth communication, overseen by an L1 contract, aiming to resolve their dispute.\n\n### Step 2: Dissection of Dispute\nThe claiment split their original claim, which covers N execution steps, into two separate claims, each representing N/2 steps. Other party then selects one of these N/2-step claims to contest, effectively reducing the dispute's scope by half. The process of halving the dispute continues, with each iteration focusing on an increasingly smaller portion of the execution steps. This iterative process is repeated until the dispute is narrowed down to a disagreement about a single step of execution.\n\n### Step 3: L1 Contract's Role\nDuring the iterative halving process, the L1 contract does not evaluate the merits of the execution; it only ensures that the protocol's rules are followed. Only when the dispute is about a single step does the L1 contract evaluate the execution to determine the correctness of the claim.\n\n### Step 4: Resolution\nBoth parties are encouraged to perform as much of the dispute resolution work off-chain as possible, minimizing the load on the L1 contract. Once the dispute is reduced to a single step, the L1 contract examines the specific instruction in question to resolve the dispute, determining whether claiment's claim is correct.\n\n## Rules to confirm or reject\nThe first unresolved RBlock can be confirmed if:\n\n- The RBlock's predecessor is the latest confirmed RBlock, and\n\n- The RBlock's deadline has passed, and\n\n- There is at least one staker, and\n\n- All stakers are staked on the RBlock.\n\nThe first unresolved RBlock can be rejected if:\n\n- The RBlock's predecessor has been rejected, or\n\n- All of the following are true:\n\n   The RBlock's deadline has passed, and\n\n   There is at least one staker, and\n\n   No staker is staked on the RBlock.",
          "title": "Dispute Resolution"
        }
      ],
      "readings": [],
      "summaries": [],
      "questions": []
    },
    {
      "key": "arbitrum-nova",
      "title": "Arbitrum Nova",
      "details": "## What is Arbitrum Nova?\nArbitrum Nova is a variant within the Arbitrum ecosystem that provides a high-performance blockchain solution. Arbitrum Nova operates on the AnyTrust protocol, which is mostly trustless but introduces a new element of trust. The core of this additional trust assumption is the Data Availability Committee (DAC), which has the task of efficiently handling Layer 2 transaction data—storing it, batching it, and then posting it to Ethereum's Layer 1. The presence of the DAC in the AnyTrust protocol is what allows Arbitrum Nova to offer enhanced performance and cost-effectiveness, making it suitable for use cases where these attributes are prioritized. \n\n## What is Anytrust Protocol \nThe AnyTrust protocol is a variation of the Arbitrum Nitro technology designed to reduce costs by incorporating a slight trust assumption. Instead of requiring every node within the Arbitrum network to have access to all Layer 2 transaction data—typically ensured by posting this data on Ethereum's Layer 1, AnyTrust delegates this responsibility to a Data Availability Committee. This committee, comprising multiple members, operates under the assumption that at least two members are honest. Consequently, even if the majority collude, the integrity of data availability is maintained, allowing the rollup protocol to function correctly and reducing the reliance on Ethereum's more costly data posting process.\n\n### Benefits of AnyTrust\nThe benefits of AnyTrust are extensive including:\n\n#### 1. Cost Reduction \nThe AnyTrust protocol reduces costs on the Arbitrum system by entrusting a Committee with data storage and distribution, thus minimizing the data posted to Ethereum's mainnet. Through a managed system of public keys and signatures called Keysets, it ensures data integrity while lessening the gas fees typically incurred for data posting.\n\n#### 2. Operational Efficiency \nThe KeysetManager contract on L1 manages Keysets to facilitate secure and flexible operation of the Committee, allowing for easy updates to membership and keys. This ensures data availability and supports a trust-minimized, efficient blockchain ecosystem.",
      "explanations": [
        {
          "key": "anytrust-security-method",
          "shortTitle": "Security",
          "details": "## The AnyTrust Security\nAnyTrust security harnesses a strategic balance between trust and decentralization, elevating the robustness of Arbitrum's rollup infrastructure. By forming a Data Availability Committee, AnyTrust fortifies data integrity and accessibility. It consists of the following components:\n\n### Data Availibility Committee\nThe Data Availability Committee is a specialized group within the AnyTrust protocol framework, tasked with the crucial role of storing and ensuring the accessibility of Layer 2 transaction data for Arbitrum's rollup chain. This committee is comprised of multiple appointed members, operating under the fundamental assumption that at least two members are consistently honest and reliable. The integrity of the system hinges on this assumption, as it guarantees the availability of data, even in scenarios where other members may act maliciously or fail. \n\nThe committee's operation is governed by a set of cryptographic public keys, known as Keysets, which establish the identity and authenticity of member signatures. These Keysets are dynamically manageable via a smart contract on Ethereum's Layer 1, known as the KeysetManager, which tracks and authenticates the current valid set of committee members. This arrangement not only ensures the security and availability of transaction data but also introduces a mechanism for manageable trust, reducing the dependency on Ethereum's mainnet and leading to a more efficient and cost-effective rollup process.\n\n### Data Availibility Certificates\nThe Data Availability Certificate (DACert) is an essential component of the AnyTrust protocol, ensuring data accessibility in the Arbitrum network. A DACert includes a data block's hash, an expiration time, and cryptographic evidence that N-1 Committee members have endorsed it. This evidence comprises the Keyset's hash used for signing, a bitmap of the signatories, and a collective BLS signature. Under AnyTrust’s trust model, a valid DACert guarantees that the data will be available from at least one trustworthy Committee member until the expiration time. \n\nIn contrast to the standard Nitro practice where sequencers post full data on Ethereum's Layer 1, AnyTrust permits posting a DACert as a more gas-efficient alternative. The Layer 1 inbox contract validates the Keyset, while Layer 2 code performs additional checks on the signature and expiration time to ensure the DACert's validity. If the DACert passes these checks, the associated data block is considered available, thereby optimizing the data posting process by reducing the on-chain footprint and maintaining data availability.\n\n### Data Availibility Server \nCommittee members in the AnyTrust protocol operate Data Availability Servers (DAS), which provide crucial infrastructure for data storage and retrieval. The DAS implements two distinct application programming interfaces (APIs):\n\n1. **Sequencer API:** This is a JSON-RPC interface exclusive to the Arbitrum chain's Sequencer, through which the Sequencer submits data blocks to be stored by the DAS. Access to this API is typically restricted to the Sequencer to prevent unauthorized submissions.\n\n2. **REST API:** Available publicly, this HTTP(S)-based RESTful API allows any participant to fetch data blocks using their hash. It is designed to be fully cacheable, and deployments often employ caching proxies or content delivery networks (CDNs) to enhance scalability and mitigate the risk of denial-of-service (DoS) attacks.\n\nWhile the Sequencer API is essential only for Committee members, the REST API's functionality is often supported by other entities as well, contributing positively to the system's robustness. The DAS software itself is versatile, with configuration options that allow data to be stored in various ways—locally on file systems, within a Badger database across multiple backing stores for redundancy. Furthermore, the DAS includes features for enhanced performance and reliability, such as optional in-memory caching utilizing Bigcache or external caching with a Redis instance, catering to the diverse needs of data storage and access in the AnyTrust ecosystem. This multi-faceted approach ensures that data is not only stored securely but is also readily available for validation and use by the network, thus maintaining the continuity and efficiency of the Arbitrum protocol.",
          "title": "Anytrust Security Method"
        },
        {
          "key": "working-of-anytrust",
          "shortTitle": "working",
          "details": "## Sequencer-Committee Interaction\nHere's the step-by-step process detailing the interaction between the Arbitrum sequencer and the Data Availability Committee during block validation in the Arbitrum AnyTrust protocol:\n\n### Step 1:Batch Creation\nThe Arbitrum sequencer generates a data batch for submission and sets an expiration time, typically three weeks ahead. The sequencer sends this batch data along with the expiration time to all Committee members simultaneously via an RPC (Remote Procedure Call) interface.\n\n### Step 2: Data Storage by Committee Members\nEach Committee member receives the batch and stores the data in its own backing store, using the data’s hash as an index for future retrieval. Committee members then sign the pair consisting of the data’s hash and the expiration time using their individual BLS cryptographic keys.\n\n### Step 3: DACert Creation\nThe Committee members send their signatures back to the sequencer. Each returns a signature accompanied by an indicator of successful storage. Once the sequencer receives the required number of signatures, it aggregates them to form a Data Availability Certificate (DACert) for the data batch.\n\n### Step 4: DACert Posting\nThe sequencer posts this DACert to the Layer 1 (L1) inbox contract. The DACert is now available for the AnyTrust Layer 2 (L2) chain software, which can validate the data's availability based on it. If the sequencer cannot obtain the necessary signatures within a specified time frame, it defaults to the traditional rollup method. It then posts the full data directly to the L1 chain, bypassing the Committee. The L2 software is designed to recognize both data formats—either provided through a DACert or posted in full. It processes the data accordingly to continue the chain’s operation seamlessly.\n\nThis process ensures that the AnyTrust protocol can validate blocks efficiently while offering a contingency plan to maintain the chain's integrity and continuity.",
          "title": "Working of Anytrust"
        },
        {
          "key": "difference-between-anytrust-and-rollup",
          "shortTitle": "Nova vs One",
          "details": "## Differences between Arbitrum Nova (AnyTrust) and Arbitrum One (Rollup)\nArbitrum One and Arbitrum nova are based on different block authentication mechanisms which results in different use face, operations and cost. Some of the major differences between two chains are listed in the table below.\n\n\n| Feature               | Arbitrum One (Rollup)                                                        | Arbitrum Nova (AnyTrust)                                               |\n|-----------------------|------------------------------------------------------------------------------|------------------------------------------------------------------------|\n| **Data Authenticity** | Layer 2 transaction data is posted on the Ethereum blockchain.               | Uses AnyTrust technology with a Data Availability Committee (DAC).     |\n| **Trust Assumption**  | Trustless and permissionless, open for anyone to validate.                   | Relies on at least two honest DAC members to operate securely.         |\n| **Gas Price**         | Minimum gas price is 0.1 gwei.                                               | Minimum gas price is 0.01 gwei, potentially 10x cheaper.               |\n| **Scalability**       | Suitable for general use cases.                                              | More scalable, designed for high-load dApps like NFTs and social networks. |\n| **DeFi Protocols**    | Higher TVL with major DeFi protocols like Uniswap, Aave, and Curve.          | Lower TVL with a focus on gaming and social, includes Sushi and others.   |\n| **Transaction Costs** | Relatively higher due to full data posting on Ethereum.                      | Lower costs due to only posting certificates on Layer 1.               |\n",
          "title": "Difference between Anytrust and Rollup"
        }
      ],
      "readings": [],
      "summaries": [],
      "questions": []
    },
    {
      "key": "arbitrum-orbit",
      "title": "Arbitrum Orbit",
      "details": "## What is Orbit?\nArbitrum Orbit enables the creation of private blockchain chains with customizable features, such as governance and fee structures, which settle transactions on Arbitrum's Layer 2 ecosystems like Arbitrum One or Nova. It utilizes the Arbitrum Nitro technology stack, offering benefits like Nitro's fraud proofs, advanced data compression, and EVM+ compatibility, while also allowing for ongoing upgrades from the Nitro stack developments. Orbit chains can be tailored for specific applications or broader use cases, offering gas price stability, permissioned access, and the choice between Rollup or AnyTrust protocols. Governance is independently determined by the chain creators, providing a flexible, scalable, and secure platform for hosting a range of dApps or private EVM-compatible smart contracts, with the ability to incrementally adopt Ethereum's security features.\n\n## Benefits of Orbit\nArbitrum Orbit addresses several key challenges within the Ethereum ecosystem:\n\n**1. Scalability:** Orbit facilitates scalability by allowing the creation of multiple chains. This helps alleviate scaling challenges by distributing activities across various environments, each with its own resource management, thereby easing bottlenecks that could arise on a single chain.\n\n**2. Flexible Security Models**: With Orbit, developers can implement and test different security models to find the right balance for their projects. For instance, while Arbitrum One offers a fully trustless environment, Arbitrum Nova provides an option to optimize for lower fees with a mild trust assumption. Orbit extends this flexibility, making experimentation with security tradeoffs more accessible.\n\n**3. Flexible Execution Environments**: Orbit chains allow for customized execution environments. While maintaining full EVM compatibility, Orbit chains can also limit smart contract functionalities to better serve specific project requirements, leading to optimized performance.\n\n**4. Flexible Governance**: Developers have the autonomy to establish their own governance mechanisms on Orbit chains, which can be tailored to suit the unique needs of their projects, communities, or stakeholders.\n\n**5. Increased Adoption of dApps**: Orbit lowers barriers to progressive decentralization, making it more feasible for developers to launch decentralized applications. It enables a new breed of dApps that benefit from being built in more autonomous, self-managed conditions, potentially increasing the adoption and diversity of dApps within the blockchain space.",
      "explanations": [
        {
          "key": "owning-the-orbit-chain",
          "shortTitle": "Orbit Ownership",
          "details": "## Orbit Licensing \nThe licensing for Arbitrum Orbit chains is designed to provide both security and flexibility for developers using the Arbitrum Nitro codebase. When you create an Orbit chain, you receive a license that is both perpetual, meaning it cannot be revoked, and recursive, allowing your Orbit chain to host further chains under the same licensing terms. This ensures that once you've developed your Orbit chain, you retain unfettered and ongoing access to the software, and you can extend these rights to additional chains created within your Orbit chain's ecosystem.\n\nHowever, this license applies specifically to chains that settle to an Arbitrum-DAO-governed chain. If you wish to establish an independent Layer 2 chain on Ethereum that does not settle to an Arbitrum-DAO chain, you must obtain a separate license. For this, you have two avenues:\n\n**1. Offchain Labs**: You can directly request a custom license from Offchain Labs, the original developers of the Arbitrum Nitro codebase and the primary licensor.\n\n**2. Arbitrum DAO Proposal**: Alternatively, you can submit a proposal to the Arbitrum DAO, which has been granted co-licensor rights. The DAO will then make a democratic decision on whether to grant a license for your new L2 chain.\n\n## How to customize your Orbit chain's deployment configuration?\nTo customize your Orbit chain's configuration, follow these steps when you access the Orbit chain deployment portal:\n\n### Step1: Access the Deployment Portal\nNavigate to the Orbit chain deployment portal where you'll launch your new Orbit chain. You will encounter a form with various configuration fields. This form typically comes with default values that are suitable for many cases but can be customized.\n\n### Step 2: Update Information\nFor devnets, the Chain ID is automatically assigned and isn't crucial. In production, you'll choose a unique integer identifier that hasn’t been used on chain indexes like Chainlist.org. Enter a distinctive name for your Orbit chain that is easily recognizable to your users and developers.\n\n### Step 3: Customise Specifications\nDecide on the Challenge period in blocks, balancing the time validators have to dispute states against the withdrawal delay for users. This is measured in blocks of the underlying L1 chain. Specify the token for validators to use as a stake, using the token's contract address on the L2 chain to which your Orbit chain settles, or use the address for ETH if that's the chosen stake token. Set the Base stake amount, considering that a lower stake lowers the barrier to entry but may increase vulnerability to attacks, while a higher stake deters attacks but raises the barrier to validator participation.\n\n### Step 4: Owner\nProvide the account address that will own and manage the Orbit chain's base contracts. In a production environment, this address might be governed by a DAO or a multisig, but for a devnet, it can be a standard Ethereum wallet address. Carefully review the default values and modify them based on the needs and security considerations of your project. Once you've finalized the configuration values, proceed with the deployment, ensuring that the Owner address has sufficient ETH to cover gas costs for contract deployment on L2.\n\nBy customizing these settings, you can tailor your Orbit chain to the specific requirements of your application, balancing security, participation, and administrative control according to your project's needs.",
          "title": "Owning the Orbit Chain"
        },
        {
          "key": "how-to-launch-an-orbit-chain",
          "shortTitle": "Launching Chain",
          "details": "## Steps to launch an Orbit Chain\n\n### Prerequisites\n\n- Docker\n\n- A browser-based Ethereum wallet (like MetaMask)\n\n- At least 1.5 testnet ETH\n\n### Step 1: Aqcuire Arbitrum Testnet $ETH\nTo initiate your Orbit chain, a minimum of 1.5 testnet ETH is required to fund the deployment of the foundational contracts to the chosen base chain, which can be either Arbitrum Goerli or Sepolia. With Sepolia being the preferred choice due to the planned obsolescence of Goerli, you should secure your testnet ETH from an Ethereum Layer 1 faucet for either Goerli or Sepolia. Once obtained, you can transfer your L1 testnet ETH to the corresponding Arbitrum Layer 2 testnet through the Arbitrum bridge.\n\n### Step 2: Choose Chain Type: Anytrust vs Roll up\nArbitrum Rollup ensures a secure, open validation process by storing data on Ethereum L1, while Arbitrum AnyTrust reduces fees through a trusted Data Availability Committee managing data off-chain. Rollup chains are recommended for highly secure applications such as DeFi platforms, while AnyTrust is better suited for transaction-intensive applications like games and social dApps that prioritize lower fees. Then Configure the orbit chain's deployment using the step by step guide available in the previous slide.\n\n### Step 3: Configure Validators and batch Poster\nIn the Configure Validators section of the Orbit chain deployment, you'll specify the number of validators and their addresses for your chain. The first validator's address is auto-generated, with its private key saved in a configuration file. These validators will ensure transaction integrity and manage the state of your Orbit chain on the base chain. They will be included in an allow-list on your chain's base contract, granting them permission to stake and validate. The terms \"base contracts\" and \"base chain\" refer to the L2 contracts of your Orbit chain and the L2 network they're deployed on, respectively. After setting up validators, you'll move on to configure the batch poster. In the Configure Batch Poster section, an address for the batch poster will be auto-generated, responsible for posting transaction batches from your Orbit chain to its base chain's contracts. Its private key is also auto-generated and stored in a JSON configuration file. After configuring this address, you proceed to the next deployment phase of your Orbit chain.\n\n### Step 4: Deploye Orbit Chain\nTo deploy your Orbit chain's base contracts, click the Deploy button on the configuration form, which prompts a transaction submission to the Arbitrum Goerli or Sepolia testnet from your wallet, incurring a minor gas fee payable in testnet ETH. This action deploys your chain's base contracts through an Orbit factory contract on Arbitrum's L2 testnet, which sets up your chain's infrastructure for transaction processing, staking, and other critical operations. After completing this transaction, you'll either move to configure a keyset for an AnyTrust chain or proceed to download configuration files to launch your chain, depending on your chosen chain type.\n\n### Step 5: Keysets Configuration (Anytrust Only)\nThe Batch Poster's functionality hinges on activating a keyset in the SequencerInbox contract, using keyset and hash binaries. For Orbit AnyTrust chains, an initial keyset is generated and linked to the SequencerInbox during deployment. Post-deployment, completing a transaction with a gas fee on the Arbitrum testnet redirects you to a download page to advance your chain's setup.\n\n### Step 6: Set Up Orbit Chain's Local Development Environment\nAfter deploying your Orbit chain, you'll be presented with two JSON configurations: Rollup Config and L3 Config. You should download both:\n\n1. **Rollup Config**: Saves as `nodeConfig.json`, containing your chain's node settings and the private keys for the validator and batch poster to sign transactions.\n\n2. **L3Config**: Saves as `orbitSetupScriptConfig.json`, holding your chain's overall settings, including those for Token Bridge contracts.\n\nNext, to set up your local environment:\n\n1. Clone the `orbit-setup-script` repository from GitHub.\n2. Place the `nodeConfig.json` file into the `config` directory of the cloned repository.\n3. Similarly, move the `orbitSetupScriptConfig.json` file into the `config` directory.\n4. Install necessary dependencies by executing `yarn install` in the repository's root directory. \n\n### Step 7: Finish Setting up Chain\nStart Docker and execute `docker-compose up -d` in the orbit-setup-script repository's root directory to initiate a Nitro node and BlockScout explorer. You can then navigate to `http://localhost:4000/` to interact with the BlockScout explorer, enabling you to inspect transactions and blocks on your chain for debugging purposes. A provided Hardhat script automates several setup tasks, including funding validator and batch-poster accounts, depositing ETH through the bridge, deploying Token Bridge contracts, and setting chain parameters. Execute this script from the orbit-setup-script repository's root, substituting `0xYourPrivateKey` with your Owner account's private key and the local RPC URL with your node's. \n\n- For Arbitrum Goerli, use\n`PRIVATE_KEY=\"0xYourPrivateKey\" L2_RPC_URL=\"https://goerli-rollup.arbitrum.io/rpc\" L3_RPC_URL=\"http://localhost:8449\" yarn run setup`. \n\n- For Arbitrum Sepolia, \n`PRIVATE_KEY=\"0xYourPrivateKey\" L2_RPC_URL=\"https://sepolia-rollup.arbitrum.io/rpc\" L3_RPC_URL=\"http://localhost:8449\" yarn run setup`.",
          "title": "How to launch an Orbit Chain?"
        },
        {
          "key": "how-to-customise-orbit-chains-behaviour",
          "shortTitle": "Customization",
          "details": "## How to Customise Orbit Chain's Behaviour \nModifying your Orbit chain's State Transition Function (STF), responsible for block generation, requires updating the fraud proof system for changes like new EVM opcodes or gas rules to be recognized. Simple updates, like adding RPC methods or altering transaction order, don't impact consensus and don't need these adjustments. To be compatible with Arbitrum Nitro, STF changes must ensure determinism, preserve historical block integrity, avoid external dependencies, confine state changes to Ethereum's state trie, maintain quick processing for node synchronization, and consistently produce blocks without errors.\nIf you're looking to alter the State Transition Function, it's necessary to create a custom version of the Arbitrum Nitro node Docker image. The behaviour of an orbit chain can be customised by following the steps given below:\n\n### Step 1: Download Nitro Source Code\nStart by duplicating the Nitro repository:\n\n`git clone --branch v2.1.1 https://github.com/OffchainLabs/nitro.git\ncd nitro\ngit submodule update --init --recursive --force\n`\n\nProceed to apply your modifications to the State Transition Function.\n\n### Step 2: Run Node Without Fraud Proof\nFor building the custom Arbitrum Nitro node Docker image, ensure Docker is installed by checking with docker version in the terminal. If it's not installed, refer to Docker's official guide or install it using your Linux distribution's package manager and enable the Docker service. With Docker ready, navigate to the Nitro directory and build your custom node using the command `docker build . --tag custom-nitro-node`. After constructing your Nitro node image, edit your node's `nodeConfig.json` file, typically in the `config` directory, to include the `--node.staker.dangerous.without-block-validator` parameter under the staker configuration to bypass fraud proof checks.\nHere's an example snippet for the nodeConfig.json:\n`...\n\"staker\": {\n  ...\n  \"dangerous\": {\n    \"without-block-validator\": true\n  }\n  ...\n},\n...\n`\nYou can launch your node in two ways:\n\n1. Via docker-compose: Update the docker-compose.yml file to use custom-nitro-node for the Nitro service, then execute docker compose up to start all services.\n`...\nnitro:\n  image: custom-nitro-node\n  ports:\n...\n`\n2. Directly with docker run: To run just the Nitro node, use:\n`docker run --rm -it -v /path/to/your/node/dir:/home/user/.arbitrum -p 0.0.0.0:8449:8449 custom-nitro-node --conf.file /home/user/.arbitrum/nodeConfig.json`\n\n### Step 3: Enable Fraud Proof\nTo enable fraud proofs, you'll need to build the \"replay binary\", which defines the State Transition Function for the fraud prover. The replay binary (sometimes called the machine) re-executes the State Transition Function against input messages to determine the correct output block. It has three forms:\n\nThe replay.wasm binary is the Go replay binary compiled to WASM. It's used by the JIT validator to verify blocks against the fraud prover.\nThe machine.wavm.br binary is a compressed binary containing the Go replay binary and all its dependencies, compiled to WASM, then translated to the Arbitrum fraud proving variant WAVM. It's used by Arbitrator when actually entering a challenge and performing the fraud proofs, and has identical behavior to replay.wasm.\nThe WASM module root (stored in module-root.txt) is a 32 byte hash usually expressed in hexadecimal which is a merkelization of machine.wavm.br. The replay binary is much too large to post on-chain, so this hash is set in the L1 rollup contract to determine the correct replay binary during fraud proofs.\nTo run a validator node with fraud proofs enabled, the validator node's Docker image will need to contain all three of these versions of the replay binary.\n\n#### Build a dev image\nThe simplest way to build a Docker image with the new replay binary is to build a dev image. These images contain a freshly built replay binary, but note that the replay binary and corresponding WASM module root will generally change when the code is updated, even if the State Transition Function has equivalent behavior. It's important that the validator's WASM module root matches the on-chain WASM module root, which is why this approach is harder to maintain. Over the longer term, you'll want to maintain a separate build of the replay binary that matches the one currently on-chain, usable by any node image.\n\nTo build the dev node image and get the WASM module root, run:\n\n`docker build . --target nitro-node-dev --tag custom-nitro-node-dev\ndocker run --rm --entrypoint cat custom-nitro-node-dev target/machines/latest/module-root.txt`\n\nOnce you have the WASM module root, you can put it on-chain by calling `setWasmModuleRoot(newWasmModuleRoot)` on the rollup contract as the owner. The rollup contract address can be found in the chain deployment info JSON. You can confirm that the WASM module root was updated by calling `wasmModuleRoot()` on the rollup contract.\n\nOnce you have set the new WASM module root on-chain, you can re-enable fraud proofs and run your node.\n\nTo re-enable fraud proofs, open your `nodeConfig.json` file again, and remove the \"dangerous\" section (containing the `without-block-validator` property) that you previously added.\n\nAfter that, you'll have, again, two ways of running your node.\n\n1. Using the docker-compose file\n\nAs mentioned before, this is the recommended way if you're running your Orbit chain locally through the provided docker-compose file. In `docker-compose.yml`, modify the Docker image used for the Nitro container. Notice that we'll now use the `custom-nitro-node-dev` you just created:\n\n`...\nnitro:\n  image: custom-nitro-node-dev\n  ports:\n...`\n\nAnd run docker compose up to run all of your containers.\n\n2. Use docker run to run your Nitro node only\n\nThis method will only run the customized Nitro node (i.e., it will not run Blockscout, or the DA server if you're using an AnyTrust chain). Use the following command:\n\n`docker run --rm -it -v /path/to/your/node/dir:/home/user/.arbitrum -p 0.0.0.0:8449:8449 custom-nitro-node-dev --conf.file /home/user/.arbitrum/nodeConfig.json`\n\n\n####  Preserving the replay binary\nThe primary issue with simply using a nitro-node-dev build is that, whenever the code changes at all, the replay binary will also change.\n\nIf the node is missing the replay binary corresponding to the on-chain WASM module root, it will be unable to act as a validator. Therefore, when releasing new node Docker images it's important to include the currently on-chain WASM module root.\n\nTo do that, you'll need to first extract the replay binary from the nitro-node-dev Docker image built earlier:\n\n`docker run --rm --name replay-binary-extractor --entrypoint sleep custom-nitro-node-dev infinity\ndocker cp replay-binary-extractor:/home/user/target/machines/latest extracted-replay-binary\ndocker stop replay-binary-extractor\ncat extracted-replay-binary/module.root\nmv extracted-replay-binary \"target/machines/$(cat extracted-replay-binary/module.root)\"`\n\nThese commands will output the new WASM module root, and create the directory `target/machines/<wasm module root>.` There you'll find the three versions of the replay binary mentioned earlier: `replay.wasm`, `machine.wavm.br`, and `module-root.txt`, along with some other optional files. Now that you've extracted the replay binary, there are two ways to add it to future Docker images, including non-dev image builds. You can either keep it locally and copy it in, or host it on the web.\n\nOption 1: Store the extracted replay binary locally\nNow that we've extracted the replay binary, we can modify the `Dockerfile` to copy it into new Docker builds. Edit the Dockerfile file in the root of the nitro folder, and after all the `RUN ./download-machines.sh ...` lines, add:\n\n`COPY target/machines/<wasm module root> <wasm module root>\nRUN ln -sfT <wasm module root> latest`\n\nReplace each `<wasm module root>` with the WASM module root you got earlier.\n\nOption 2: Host the replay binary on the web\nTo support building the Docker image on other computers without this local machine directory, you'll need to either commit the machine to git, or preferably, host the replay binary on the web.\n\nTo host the replay binary on the web, you'll need to host the `replay.wasm` and `machine.wavm.br` files somewhere. One good option is GitHub releases, but any hosting service works.\n\nOnce you have those two files hosted, instead of the `COPY` and `RUN` command mentioned in option 1, you'll need to add these new lines to the Dockerfile file in the root of the nitro folder, after all the `RUN ./download-machines.sh ...` lines:\n\n`RUN wasm_module_root=\"<wasm module root>\" && \\\n    mkdir \"$wasm_module_root\" && \\\n    wget <url of replay.wasm> -O \"$wasm_module_root/replay.wasm\" && \\\n    wget <url of machine.wavm.br> -O \"$wasm_module_root/machine.wavm.br\" && \\\n    echo \"$wasm_module_root\" > \"$wasm_module_root/module-root.txt\" && \\\n    ln -sfT \"$wasm_module_root\" latest`\n\nReplace the `<wasm module root>` with the WASM module root you got earlier, the `<url of replay.wasm>` with the direct link to the `replay.wasm` file (it must be a direct link to the file and not just a download site), and the `<url of machine.wavm.br>` with the direct link to the `machine.wavm.br` file.\n\n### Step 4: Verify Fraud Proofs\nWith your Docker images ready, test your blockchain by making transactions and monitoring for \"validation succeeded\" in the logs, indicating the State Transition Function is working. If you encounter \"Error during validation,\" check that your replay binary is updated with your latest changes and the WASM module root in the rollup contract is correctly set to match your binary.\n\n## Chain Parameters\nChain parameters define the essential rules and configurations for a blockchain network, such as block size, block time, consensus rules, and network IDs, ensuring that all nodes on the network are in sync and follow the same protocol for validating and adding transactions. They are critical for maintaining the blockchain's integrity and security.\n\n| Param                | Description                                                                                               | Arbitrum One               | Nova                      | Arb Goerli                | Arb Sepolia               |\n|----------------------|-----------------------------------------------------------------------------------------------------------|----------------------------|---------------------------|---------------------------|---------------------------|\n| Dispute window       | Time for assertions to get confirmed during which validaors can issue a challenge                         | 45818 blocks (~ 6.4 days ) | 45818 blocks (~ 6.4 days) | 20 blocks (~ 4.0 minutes) | 20 blocks (~ 4.0 minutes) |\n| Base stake           | Amount of stake required for a validator to make an assertion                                             | 1 ETH                      | 1 ETH                     | 1 Goerli ETH              | 1 Sepolia ETH             |\n| Force-include period | Period after which a delayed message can be included into the inbox without any action from the Sequencer | 5760 blocks / 24 hours     | 5760 blocks / 24 hours    | 5760 blocks / 24 hours    | 5760 blocks / 24 hours    |\n| Gas speed limit      | Target gas/sec, over which the congestion mechanism activates                                             | 7,000,000 gas/sec          | 7,000,000 gas/sec         | 3,000,000 gas/sec         | 7,000,000 gas/sec         |\n| Gas price floor      | Minimum gas price                                                                                         | 0.1 gwei                   | 0.01 gwei                 | 0.1 gwei                  | 0.1 gwei                  |\n| Block gas limit      | Maximum amount of gas that all the transactions inside a block are allowed to consume                     | 32,000,000                 | 32,000,000                | 20,000,000                | 32,000,000                |\n",
          "title": "How to Customise Orbit Chain's Behaviour "
        }
      ],
      "readings": [],
      "summaries": [],
      "questions": []
    },
    {
      "key": "arbitrum-stylus",
      "title": "Arbitrum Stylus",
      "details": "## What is stylus \nStylus is a cutting-edge tool designed to enhance the development of smart contracts on the Arbitrum platform, which is part of the broader Ethereum ecosystem. It expands the capabilities of smart contract creation on the Arbitrum platform by allowing developers to utilize a wide array of programming languages that compile into WebAssembly (WASM). This means that languages such as Rust, C, and C++ can now be employed to write EVM-compatible smart contracts. This is enabled through the use of the Stylus Software Development Kit (SDK) and its accompanying command-line interface (CLI) tool. It leverages Arbitrum's existing WASM infrastructure to ensure that these smart contracts benefit from the platform's efficient execution environment, which translates into faster performance and reduced gas costs. This efficiency gain is attributed to WASM's modern binary format, known for speed, portability, and security. \n\nStylus represents an upgrade to Arbitrum Nitro, a technology stack that powers various Arbitrum chains, and is part of the EVM+ paradigm, maintaining full interoperability with existing Solidity contracts. The innovation of Stylus lies in its ability to deterministically prove the correctness of any program that compiles to WASM, owing to Arbitrum Nitro's unique fraud-proving capabilities, which are integral to maintaining network integrity and trust.\n\n## Importance of stylus\nStylus has transformed the developement of smart constracts. Some of the key advantages are:\n\n**1. Multi-Language Support:** Stylus broadens access to Arbitrum's blockchain development by accommodating a variety of programming languages. With only 20,000 Solidity developers, the inclusion of Rust and C—with their combined 15 million developers—could greatly accelerate the platform's growth and user adoption.\n\n**2. EVM Compatibility:** Stylus combines the traditional benefits of the EVM with improved efficiency and a rich set of libraries from languages like Rust, C, and C++, elevating the standard for smart contract development without altering EVM's core functionality.\n\n**3. Cost-Effective Advanced Cryptography:** Stylus enables previously impractical use cases with more than tenfold computational and over a hundredfold memory efficiency improvements. It allows for the deployment of custom cryptography libraries, fostering a new era of blockchain innovation.\n\n**4. Opt-In Reentrancy Protection:** Stylus not only saves money and runs faster but also increases security. It automatically guards against reentrancy, a common problem in smart contracts, and this feature is turned on from the start to prevent issues.\n\n**5. Full Interoperability:** Solidity and WASM programs can work together smoothly. Developers can mix languages, using Solidity to run Rust code, or vice versa, without any extra setup.",
      "explanations": [
        {
          "key": "how-does-it-work",
          "shortTitle": "working",
          "details": "## Working of Stylus \nHere's a step-by-step process explaining how Stylus works:\n\n### Step 1: Coding\nDevelopers write smart contracts in languages like Rust, C, or C++. These languages are chosen because they can be compiled into efficient WebAssembly (WASM) code. Rust is the most supported on launch, with a dedicated SDK to simplify smart contract development. Developers can use familiar EVM functionalities within the Rust environment.\n\n### Step 2: Compilation\nThe written program is first compiled into WASM using appropriate tools like the Stylus SDK for Rust or compilers like Clang for C/C++. After compilation, the WASM code is uploaded to the blockchain, but it’s not yet executable. A special process called \"activation\" is then required. This involves using the ArbWasm precompile to convert WASM into binary code that’s optimized for the node’s architecture, ensuring the program is safe and efficient for execution.\n\n### Step 3: Execution\nStylus programs run on a modified version of Wasmer, a leading WebAssembly runtime, which is optimized for blockchain applications. This allows Stylus programs to execute much faster than traditional EVM bytecode. Despite the introduction of Stylus, existing EVM contracts operate as usual. Both Solidity and WASM contracts are fully interoperable, allowing cross-contract calls without language barriers.\n\n### Step 4: Proving\nIn normal operations (the \"happy case\"), Nitro compiles execution history to native code to ensure efficiency. If a dispute arises (the \"sad case\"), Nitro uses WASM to perform interactive fraud proofs on Ethereum. Stylus extends Nitro's fraud-proofing capability by enabling it to work with any WASM program deployed by developers, maintaining the integrity and trustworthiness of the blockchain. ",
          "title": "How does it work?"
        }
      ],
      "readings": [],
      "summaries": [],
      "questions": []
    }
  ]
}