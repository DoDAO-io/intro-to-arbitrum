{
  "key": "dodao-course-template",
  "title": "Introduction to Arbitrum",
  "summary": "This is a course that provides a deeper understanding into the working and technicalities of Arbitrum, the leading scalability solution for Ethereum.",
  "details": "",
  "duration": "30 mins - 1 hour",
  "highlights": [
    "Introduction",
    "Arbitrum Nitro",
    "Arbitrum One",
    "Arbitrum Nova",
    "Arbitrum Orbit",
    "Arbitrum Stylus"
  ],
  "publishStatus": "Live",
  "thumbnail": "https://d31h13bdjwgzxs.cloudfront.net/courses/DoDAO/CourseIcons/audit_and_monitoring.png",
  "courseAdmins": [
    "0x34d014758297c00fea49935fce172677904d51ef",
    "0x2a6af0619be90d129ab0d70c10e25c097b6ec67d"
  ],
  "topicConfig": {
    "showExplanations": true,
    "showHints": true
  },
  "topics": [
    {
      "title": "Introduction",
      "key": "introduction",
      "details": "## What is Arbitrum\n\nArbitrum is a Layer 2 scaling solution designed to enhance the Ethereum blockchain's scalability and efficiency. It processes transactions separately from Ethereum's main chain and utilizes Rollup technology to combine multiple transactions into one, increasing throughput and reducing costs. Arbitrum maintains compatibility with Ethereum's existing tools and smart contracts, allowing for straightforward application deployment. Developed by Offchain Labs, it includes the Arbitrum One mainnet, which supports smart contract execution with Ethereum network validation. The use of Arbitrum significantly lowers transaction fees, making it a cost-effective alternative for running decentralized applications and smart contracts compared to Ethereum's mainnet.\n\n## What is Layer 2 \n\nLayer 2 refers to a secondary framework or protocol that is built on top of an existing blockchain system, known as Layer 1. The primary purpose of Layer 2 solutions is to address the scalability and performance issues of the main blockchain by handling transactions off the main chain. This allows for faster processing times and reduced transaction costs, without compromising the decentralized security model of the underlying blockchain. Layer 2 solutions include various technologies such as state channels, sidechains, and rollups, each with their own approach to off-chain transaction handling and subsequently settling the final state on-chain.\n\n## Benefits of Layer 2\n\n1. **Increased Transaction:** Throughput By handling transactions off the main chain, Layer 2 can process many more transactions per second than the base layer, alleviating congestion.\n\n2. **Reduced Costs:** Transactions on Layer 2 typically incur lower fees because they minimize the demand on the network's main chain resources.\n\n3. **Improved Speed:** Transactions can be completed faster on Layer 2, as they are not subject to the longer processing times of the main chain.\n\n4. **Enhanced Scalability:** Layer 2 can scale independently from the main chain, allowing the network to support more users and applications without a proportional increase in transaction costs or times.\n\n5. **Maintained Security:** Despite processing transactions off-chain, Layer 2 solutions typically inherit the strong security guarantees of the underlying main chain.\n\n",
      "order": 0,
      "explanations": [
        {
          "key": "arbiturm-optimistic-rollup",
          "shortTitle": "Optimistic Rollup",
          "details": "## Roll Ups\nRollups are a type of Layer 2 scaling solution that execute transactions outside the main Ethereum chain (off-chain) but record transaction data on the main chain (on-chain). The core idea is to \"roll up\" or batch many transactions into a single one, which is then posted to the main chain. This reduces the amount of data that needs to be stored and processed on the main chain, significantly increasing throughput and reducing transaction fees.\n\n### Types of Roll ups\nThere are two main types of rollups, each with its own approach to validating the batched transactions:\n\n#### Optimistic Rollups\nThese operate on the principle that all transactions are assumed to be valid by default. They only execute transaction computations on-chain in the event of a challenge. This means that instead of performing computation to prove the correctness of transactions upfront, Optimistic Rollups post the transactions along with a bond. After a challenge period, if no one disputes the transaction batch with a \"fraud proof\" showing that something was wrong, the transactions are considered valid. This method allows for significant scaling benefits, but the challenge period can introduce a delay in finalizing transactions.\n\n#### Zero-Knowledge Rollups (ZK-Rollups)\nZK-Rollups bundle transactions and generate a cryptographic proof, known as a zero-knowledge proof (specifically, a zk-SNARK or zk-STARK), attesting to their validity. This proof is then posted to the main chain, where it can be quickly verified. Because the validity of the entire batch can be confirmed without executing the transactions individually, ZK-Rollups can finalize transactions much more quickly than Optimistic Rollups. Additionally, ZK-Rollups enhance privacy since the actual transaction data can be kept off-chain.\n\n## Optimistic Rollup; How it works?\nOptimistic Rollups operates on the assumption that all transactions are honest and valid unless proven otherwise. Here's how they work:\n\n#### Step 1: Execution and Aggregation\nIn optimistic rollups, operators, or validators, process transactions by aggregating and compressing them before submitting them to Ethereum's blockchain. Any user can act as a validator by providing a bond, similar to proof-of-stake systems, and risks penalties for any invalid submissions. Validators also maintain their version of the rollup's state and can issue fraud proofs if discrepancies arise. Some rollups use a 'sequencer' instead of multiple validators, which centralizes transaction processing and submission but provides greater control over transaction order and immediate access to the rollup chain.\n\n#### Step 2: Sending Roll up Blocks to Ethereum\nOperators consolidate multiple off-chain transactions into a single batch and compress the transaction data to minimize storage costs on Ethereum. This batch is then submitted to Ethereum as 'calldata' — a temporary and immutable form of data used by smart contracts to execute functions. While 'calldata' remains in the blockchain's history, it does not become part of the Ethereum state, thereby conserving space and reducing costs. The 'calldata' keyword in Solidity is instrumental in calling smart contract functions and organizing inputs, playing a critical role in the efficient operation of optimistic rollups. \n\n#### Step 3: State Commitments\nState commitments play a crucial role in maintaining the integrity of the system. The state is structured as a Merkle tree, also known as the state tree, which contains all the information about the current state of the rollup. Operators compute new state roots reflecting the latest state changes and submit these roots to the rollup contract on Ethereum. By committing to the old and new state roots when posting transaction batches, and including the Merkle root for transactions, operators provide a verifiable record of the rollup's state changes on the Layer 1 blockchain. This mechanism ensures that the state of the rollup can be trusted and verified.\n\n#### Step 4: Fraud Proof \nThe essence of optimistic rollups lies in their fraud-proof mechanism. They allow blocks to be published without immediate validity checks. If discrepancies are suspected, users can challenge transitions within a set timeframe. Challenges trigger fraud-proof calculations, where disputed transactions are replayed on Ethereum's main network through a verifier contract. If fraud is confirmed, the responsible validator is penalized. To support this, rollups must make detailed state commitments and transaction data public on-chain, which incurs gas fees. Multi-round interactive proofs can enhance this process's efficiency by reducing the data and computation required for each verification step.\n\n#### Step 5: Multiround Interactive Proving\nMulti-round interactive proving is a critical component of optimistic rollups. It involves a dialogue between a challenger and the block's producer (asserter/operator), overseen by a Layer 1 verifier contract. If a block is challenged, the operator splits the disputed assertion for the rollup block into two, with each part undergoing repeated division through a bisection protocol until the specific point of contention is isolated. The verifier contract then adjudicates the dispute and identifies any fraudulent activity. This process ensures that only valid transactions are finalized, with the capability to penalize malicious actors, thereby maintaining the integrity of the rollup.  ",
          "title": "Arbiturm - Optimistic Rollup"
        },
        {
          "key": "arbitrum-chains",
          "shortTitle": "Types of Chains",
          "details": "Arbitrum ecosystem consists of various chains with distinct features that utilise unique technologies that enable ethereum scalability. The major arbitrum chains include.\n\n### Arbitrum One\nArbitrum One is a Layer 2 optimistic rollup solution that enhances Ethereum blockchain. It doesn't require any additional trust beyond that which is inherent to Ethereum's Layer 1. Enabled by the Nitro technology stack, Arbitrum One features efficient data handling and execution, improved transaction compression, and compatibility with Ethereum's gas system, streamlining the process while keeping security tight.\n\n### Arbitrum Nova\nArbitrum Nova is a Layer 2 scaling solution designed for high performance and cost efficiency. It operates on the AnyTrust protocol, which is a slightly less trustless system compared to Arbitrum One's Rollup protocol. The primary distinction lies in the AnyTrust protocol's reliance on a Data Availability Committee (DAC) to manage transaction data. This committee ensures the speedy and efficient handling of Level 2 transaction data before it is finalized on Ethereum's main chain. Arbitrum Nova is tailored for applications where high throughput and affordability are prioritized.\n\n### Arbitrum Orbit\nArbitrum Orbit allows the creation of personalized chains that settle transactions to Arbitrum's Layer 2 chains, such as Arbitrum One or Arbitrum Nova. You have full control over your Orbit chain, with the ability to tailor its privacy settings, permissions, governance structure, and fee token according to your specific requirements. Orbit chains can be as open or restricted as you prefer, offering a customizable path to decentralization and the option to integrate ongoing enhancements from the Arbitrum Nitro technology stack\n\n## How is arbiturm diferent from other Optimistic L2 Rollups?\nArbitrum's approach prioritizes a balance of speed, cost, security, and developer accessibility, underpinning its leading market position. Some of the major differences include:\n\n### Fraud Proofs\nArbitrum sets itself apart from other Optimistic L2 Rollups primarily through its multi-round fraud proof system, which contrasts with single-round fraud proofs used by platforms like Optimism. This system verifies only challenged transactions, which may result in lower fees due to decreased reliance on Layer 1 computations.\n\n### Virtual Machine Compatibility\nThe Arbitrum Virtual Machine (AVM) is more closely optimized for EVM coding languages, making it developer-friendly as applications don't need to be rewritten to transition from the EVM to the AVM. This contrasts with Optimism's Virtual Machine (OVM), which has faced some compatibility issues with the EVM.\n\n### Transaction Finality and Fees\nDue to the multi-round fraud proof mechanism, transaction finality on Arbitrum can be slower compared to some other rollups, but this trade-off allows for lower fees because of reduced Layer 1 computation reliance​.",
          "title": "Arbitrum Chains"
        },
        {
          "key": "arbitrum-ecosystem",
          "shortTitle": "Arbitrum Community",
          "details": "The Arbitrum ecosystem boasts a vibrant network of decentralized applications, offering users enhanced transaction speed and reduced costs. With its robust compatibility with Ethereum's tools and smart contracts, it simplifies the developer experience for deploying dApps. \n\n## Stylus\nStylus is an innovative platform that extends smart contract development on the Ethereum blockchain to languages like Rust, C, and C++, diversifying beyond the conventional Solidity-centric approach. Integrated with Arbitrum Nitro's enhanced tech stack, Stylus employs the WebAssembly (WASM) virtual machine in tandem with the Ethereum Virtual Machine (EVM), enabling the execution of smart contracts authored in WASM-compatible languages on the Arbitrum network.\n\nStylus enhances the Arbitrum ecosystem by allowing developers to write smart contracts in Rust, C, and C++ and introducing significant performance enhancements for decentralized applications. It also adds the ability to create custom precompiles for advanced cryptographic functions, which, along with WASM support, enables high-speed execution and broader innovation, all while maintaining compatibility with the Ethereum ecosystem through its EVM+ integration.\n\n## Ecosystem Support\nArbitrum offers a robust support ecosystem for its users, emphasizing accessibility and community engagement. The cornerstone of this support is detailed documentation and academy site that provides a wealth of information on platform functionalities and integration processes. For interactive assistance and community-driven support, Arbitrum hosts channels like Discord, where users can seek advice, troubleshoot in real-time, and engage with both peers and the Arbitrum team. Additionally, a bug bounty program encourages the community to contribute to the platform's security, rewarding those who identify and report vulnerabilities. Users are also empowered through the Arbitrum DAO to participate in governance, offering a platform to propose and vote on changes, ensuring that the community's voice is integral to the network's evolution. For direct inquiries, a dedicated support team is likely available to handle specific issues, providing personalized help.\n\nArbitrum's comprehensive support fosters community, loyalty, and platform security, as users contribute to identifying issues via the bug bounty program. Educational resources and tutorials empower users, while governance participation ensures a democratic, community-aligned platform. This support system is vital for user operations and the network's ongoing enhancement and resilience.\n\n\n## Decentralize governance\nArbitrum's decentralized governance is orchestrated through the Arbitrum DAO, which allows stakeholders to vote on key decisions affecting both the Arbitrum One and Arbitrum Nova chains. The governance structure includes a Security Council that can make urgent or minor changes, as well as a set of allow-listed validators who confirm the chains' states. For Arbitrum Nova, there's also a Data Availability Committee tasked with data storage and availability. The governance system has the power to modify validators and Sequencers, who are responsible for transaction ordering, thereby maintaining a balance between central oversight and progressive decentralization. This governance framework is designed to evolve, with the potential for changes based on community feedback, reflecting the adaptive nature of the protocol's management.\n\nProgressive decentralization is a strategic approach to building trust and stability within a blockchain ecosystem. It starts with a centralized authority, such as the core development team, who can quickly respond to issues and update the system efficiently. Over time, control is handed over to a broader set of stakeholders, which enhances security by reducing central points of failure. It also deepens community involvement, as more participants are empowered to govern the network, which in turn fosters a more resilient and democratic infrastructure. This gradual transition allows the network to maintain continuity and stability while progressively mitigating risks and adapting to a decentralized governance structure.",
          "title": "Arbitrum Ecosystem"
        }
      ],
      "questions": [],
      "readings": [],
      "summaries": []
    },
    {
      "key": "arbitrum-nitro",
      "title": "Arbitrum Nitro",
      "details": "## What is Arbitrum Nitro?\n\nArbitrum Nitro is a significant technical upgrade for Arbitrum, which is a Layer 2 scaling solution for Ethereum. It aims to lower transaction fees and increase the processing capacity of Ethereum by moving contract computation and storage from the primary chain. This upgrade, known as Nitro, is designed to be more compatible with the Ethereum Virtual Machine (EVM) and provides a better user experience with lower fees and faster transactions. With Nitro, Arbitrum aims to push the boundaries of security, efficiency, and scalability, offering a promising solution for the future of Ethereum. \n\nIt introduces advanced calldata compression, reducing transaction costs even further. Nitro enhances the performance of Layer 1 (L1) nodes, aligns EVM operation pricing with Ethereum, and introduces additional synchronization with Ethereum L1 blocks. As it seamlessly supports the Ethereum Virtual Machine (EVM), no hefty modifications are required. With Nitro, transactions on Arbitrum have become extremely efficient. \n\n## Innovative Features of Arbitrum Nitro\n\n#### WebAssembly Code\n\nNitro introduces a new prover that uses WebAssembly (WASM) code to perform Arbitrum's interactive fraud proofs. This upgrade enhances the scalability and efficiency of the system, allowing for thousands of transactions to be processed per second. Despite being a separate blockchain, Arbitrum Nitro maintains the security and privacy features of Ethereum's Layer 1 (L1) and relays all transaction information to the main Ethereum chain.\n\n#### EVM Compatiblility\n\nDevelopers can easily integrate Arbitrum Nitro without making any modifications because it supports the EVM. This means that existing Ethereum contracts and transactions can run on Arbitrum without any changes. This distinguishes Arbitrum Nitro from other layer 2 solutions as each have their own VMs thereby requiring modifications for integration. \n\n#### Deterministic Transactions\n\nTo use Arbitrum Nitro, users need to submit their transactions to the chain's inbox. The chain will then execute the transaction and produce outputs, including a transaction receipt and any initiated withdrawals. The execution of transactions is deterministic, meaning that the result is known as soon as the transaction is placed in the inbox. Arbitrum ensures the correctness of the chain state and outputs, supports Ethereum-compatible contracts and transactions, and manages the transfer and management of ETH and tokens on the chain. ",
      "explanations": [
        {
          "key": "nitro-vs-classic",
          "shortTitle": "Differences",
          "details": "\nHere is the comparison between Arbitrum Nitro and Arbitrum Classic (original version of Arbitrum):\n\n| Feature                                  | Arbitrum Classic                                              | Arbitrum Nitro                                                  |\n|------------------------------------------|---------------------------------------------------------------|-----------------------------------------------------------------|\n| Goal                                     | Execution environment resembling EVM as second layer to Ethereum | Execution environment resembling EVM as second layer to Ethereum |\n| Virtual Machine Used                     | Arbitrum Virtual Machine (AVM)                                  | WebAssembly (Wasm)                                              |\n| Low-Level Instructions                   | Uses AVM for low-level instructions                             | Compiles Go code to WASM for low-level instructions             |\n| Architecture                             | Relies on AVM for execution environment                         | Direct usage of Geth's EVM implementation, enhancing efficiency |\n| Gas Fees and Ethereum Compatibility      | Higher fees compared to Nitro, due to less optimized execution environment | Lower fees and better Ethereum compatibility due to native execution of Go code |\n| Codebase Simplicity                      | More complex due to custom AVM, posing higher technical risks   | Simpler and more accessible codebase, reducing technical risks  |\n| Coding Languages                         | Solidity or Vyper                                                | Go (a more common language)                                     |\n| Code Conversion                          | EVM bytecode converted to AVM bytecode                           | Uses Wasm only when there's a dispute                           |\n| Transaction Management and Fraud Proofs  | AVM bytecode runs transactions and generates fraud proofs        | Checkpoints summarize transactions; Wasm used for disputes      |\n| Dispute Resolution                       | Validators inspect AVM bytecode in case of disputes              | Validators agree on block before examining Wasm details         |\n| Efficiency and Resource Management       | Less efficient, prepares for problems even if they do not occur  | More efficient, converts to Wasm only during disputes, saving time and resources |",
          "title": "Nitro vs Classic"
        },
        {
          "key": "arbitrum-nitro-design",
          "shortTitle": "Architecture",
          "details": "## How Transactions Work?\n\nDesigned to enhance efficiency and streamline workflows, the Nitro design emerges as an evidence to innovation in the Ethereum ecosystem. The transaction pocess in Arbitrum Nitro technology consists of the following cricial steps:\n\n#### Step 1: Sequencing and Deterministic Execution\n\nWhen a user sends a transaction on the Nitro chain, it is signed with their wallet and given to the Sequencer. The Sequencer orders transactions and publishes them, after which they're processed to update the Nitro chain state, producing Layer 2 blocks as needed. Invalid transactions are rejected to keep the sequence authentic. The Sequencer uses a real-time alert system for immediate soft finality and batches transactions on the Ethereum chain for hard finality. The latter involves compressing transactions using \"brotli\" and posting them to Ethereum, where their finalization ensures the sequence's immutability on Nitro.\n\n#### Step 2: State Transition Function\n\nIn Arbitrum Nitro's transaction lifecycle, the State Transition Function (STF) is crucial for updating the blockchain's state. Once a transaction is submitted, it enters the Nitro system either through a Sequencer or directly into the inbox. The STF then processes these transactions, taking the current state and the transaction data to compute a new state. It performs all the necessary calculations and state alterations in a deterministic manner, such as adjusting account balances and modifying smart contract states. This transition is then reflected on the chain, with the STF ensuring that the state progresses correctly and consistently after each transaction, maintaining the integrity and continuity of the blockchain's ledger.\n\n#### Step 3: Posting on Layer 1\n\nIn Arbitrum Nitro's transaction lifecycle, data posting on Layer 1 is where transaction inputs are recorded as calldata on the Ethereum blockchain, allowing for full transparency and enabling anyone to reconstruct the chain's state. This process supports the network's optimistic rollup approach, where validators post proposed rollup blocks to Layer 1, which are assumed correct unless challenged within a roughly one-week period. If unchallenged, the block is confirmed, but disputed blocks trigger Arbitrum's dispute resolution protocol to determine accuracy, penalizing dishonest validators with deposit forfeiture. This design ensures the integrity of posted data while minimizing fraud.\n\n## Nitro Under the Hood\n\nArbitrum Nitro's innovative architecture is designed to streamline both the execution of smart contracts and the verification process in case of disputes. Central to this architecture is the implementation of \"geth at the core,\" which utilizes go-ethereum, the commonly used Ethereum node software, written in the Go programming language. This foundational approach is manifested in a layered structure. Nitro harnesses the power of this setup to optimise performance while maintaining the robustness of security and verification processes.\n\n### Layers of Nitro Node\n\nNitro utilizes the same source code for two distinct tasks: execution and proving, by employing \"geth at the core.\" The Nitro node software, predominantly written in Go like go-ethereum (geth), consists of three main layers—the base layer with core geth functionalities, the middle layer called ArbOS providing Layer 2 features, and the top layer handling node operations, also derived from geth. This layered design forms the \"geth sandwich,\" with geth as the bread and ArbOS as the filling.\n\n### Dual Compilation Strategy\n\nFor execution, the source code is compiled into native code using the standard Go compiler, customized for the specific architecture of the node deployment. In contrast, for proving—particularly important when disputes arise—the same source code, especially the State Transition Function (STF), is compiled to WebAssembly (WASM), a portable machine code format. This WASM code is then transformed into WAVM, a modified version for proof procedures. When a dispute occurs, the verification of the STF's results is conducted with reference to the WAVM code, ensuring that the same logic governs both normal operation and the verification process during disputes.",
          "title": "Arbitrum Nitro Design "
        }
      ],
      "readings": [],
      "summaries": [],
      "questions": []
    },
    {
      "key": "arbitrum-one",
      "title": "Arbitrum One",
      "details": "xashdlwiudjio;wdksmow",
      "explanations": [],
      "readings": [],
      "summaries": [],
      "questions": []
    },
    {
      "key": "arbitrum-nova",
      "title": "Arbitrum Nova",
      "details": "jkwdnlwjekdnaiofkldnme.f/",
      "explanations": [],
      "readings": [],
      "summaries": [],
      "questions": []
    },
    {
      "key": "arbitrum-orbit",
      "title": "Arbitrum Orbit",
      "details": "saldhaiadjiokwfml,elfe",
      "explanations": [],
      "readings": [],
      "summaries": [],
      "questions": []
    },
    {
      "key": "arbitrum-stylus",
      "title": "Arbitrum Stylus",
      "details": "s,jdbaeljkfdnkoelf/melrf",
      "explanations": [],
      "readings": [],
      "summaries": [],
      "questions": []
    }
  ]
}